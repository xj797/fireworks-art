<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transient Radiance - åŒæ¨¡å¼çƒŸèŠ±ç”Ÿæˆå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: #0a0a0f;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.85);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            z-index: 100;
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #controls.hidden {
            transform: translateX(-380px);
            opacity: 0;
            pointer-events: none;
        }

        #toggle-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 45px;
            height: 45px;
            background: rgba(10, 10, 20, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 101;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s;
        }

        #toggle-controls:hover {
            background: rgba(102, 126, 234, 0.3);
            border-color: rgba(102, 126, 234, 0.5);
            transform: scale(1.05);
        }

        #toggle-controls.shifted {
            left: 360px;
        }

        #controls::-webkit-scrollbar {
            width: 6px;
        }

        #controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        #controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .control-group label .value {
            float: right;
            color: #667eea;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            outline: none;
            transition: all 0.3s;
        }

        select:hover, select:focus {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #launch-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        #launch-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        #launch-btn:active {
            transform: translateY(0);
        }

        #clear-btn {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }

        #clear-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mode-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: rgba(10, 10, 20, 0.85);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            z-index: 100;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .mode-indicator .mode {
            display: block;
            font-size: 18px;
            font-weight: 700;
            margin-top: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
        }

        .stats div {
            margin-bottom: 5px;
        }

        .info-text {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            line-height: 1.6;
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="toggle-controls">âš™ï¸</div>

    <div id="controls">
        <h1>ğŸ† Transient Radiance</h1>
        <p class="subtitle">ç¬æ—¶ç’€ç’¨ - åŒæ¨¡å¼çƒŸèŠ±ç”Ÿæˆå™¨</p>

        <div class="control-group">
            <label>é£æ ¼æ¨¡å¼ / Style Mode</label>
            <select id="mode-select">
                <option value="physics">ğŸŒ ç‰©ç†ç°å®ä¸»ä¹‰</option>
                <option value="artistic">âœ¨ è¡¨ç°è‰ºæœ¯è‡ªç”±</option>
            </select>
        </div>

        <div class="control-group">
            <label>è‰²å½©æ–¹æ¡ˆ / Color Palette</label>
            <select id="color-select">
                <option value="rainbow">ğŸŒˆ ç»šçƒ‚å½©è™¹</option>
                <option value="fire">ğŸ”¥ ç«ç„°çƒˆç„°</option>
                <option value="ice">â„ï¸ å†°é›ªå¯’éœœ</option>
                <option value="gold">ğŸ‘‘ é»„é‡‘è£è€€</option>
                <option value="neon">ğŸ’ éœ“è™¹èµ›åš</option>
                <option value="sunset">ğŸŒ… æ—¥è½æ™šéœ</option>
            </select>
        </div>

        <div class="control-group">
            <label>å‘å°„æ•°é‡ / Count <span class="value" id="count-value">5</span></label>
            <input type="range" id="count-slider" min="1" max="15" value="5">
        </div>

        <div class="control-group">
            <label>ç²’å­å¯†åº¦ / Density <span class="value" id="density-value">150</span></label>
            <input type="range" id="density-slider" min="50" max="300" value="150">
        </div>

        <div class="control-group">
            <label>é‡åŠ›å¼ºåº¦ / Gravity <span class="value" id="gravity-value">0.15</span></label>
            <input type="range" id="gravity-slider" min="-0.3" max="0.5" step="0.01" value="0.15">
        </div>

        <div class="control-group">
            <label>ç©ºæ°”é˜»åŠ› / Drag <span class="value" id="drag-value">0.98</span></label>
            <input type="range" id="drag-slider" min="0.9" max="1.02" step="0.001" value="0.98">
        </div>

        <div class="control-group">
            <label>æ‹–å°¾é•¿åº¦ / Trail <span class="value" id="trail-value">0.15</span></label>
            <input type="range" id="trail-slider" min="0.05" max="0.4" step="0.01" value="0.15">
        </div>

        <div class="control-group">
            <label>å¤šé‡çˆ†ç‚¸æ¦‚ç‡ / Multi-Burst <span class="value" id="multi-value">30%</span></label>
            <input type="range" id="multi-slider" min="0" max="100" value="30">
        </div>

        <div class="control-group">
            <label>çˆ†ç‚¸åŠ›åº¦ / Force <span class="value" id="force-value">8</span></label>
            <input type="range" id="force-slider" min="3" max="15" step="0.5" value="8">
        </div>

        <div class="control-group">
            <label>éŸ³æ•ˆè®¾ç½® / Sound</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <button id="mute-btn" style="flex: 1; padding: 8px; font-size: 12px;">ğŸ”Š å¼€å¯éŸ³æ•ˆ</button>
                <input type="range" id="volume-slider" min="0" max="100" value="50" style="flex: 1;">
            </div>
        </div>

        <div class="button-group">
            <button id="launch-btn">ğŸš€ å‘å°„çƒŸèŠ±</button>
            <button id="clear-btn">æ¸…é™¤ç”»å¸ƒ</button>
        </div>

        <div class="info-text" id="mode-info">
            <strong>ç‰©ç†ç°å®ä¸»ä¹‰ï¼š</strong>éµå¾ªç»å…¸åŠ›å­¦å®šå¾‹ï¼Œç²’å­å—é‡åŠ›å½±å“è‡ªç„¶ä¸‹è½ï¼Œå½¢æˆçœŸå®çš„æŠ›ç‰©çº¿è½¨è¿¹ã€‚é€‚åˆè¿½æ±‚ç‰©ç†å¯ä¿¡åº¦çš„è§†è§‰æ•ˆæœã€‚
        </div>

        <div class="stats">
            <div>æ´»è·ƒç²’å­: <span id="particle-count">0</span></div>
            <div>æ´»è·ƒçƒŸèŠ±: <span id="firework-count">0</span></div>
            <div>å½“å‰ç§å­: <span id="seed-display">-</span></div>
        </div>
    </div>

    <div class="mode-indicator">
        å½“å‰æ¨¡å¼
        <span class="mode" id="current-mode">ç‰©ç†ç°å®ä¸»ä¹‰</span>
    </div>

    <script>
        // å…¨å±€å‚æ•° - å¯¹åº”ç®—æ³•å“²å­¦
        let params = {
            mode: 'physics',  // 'physics' æˆ– 'artistic'
            colorScheme: 'rainbow',
            fireworkCount: 5,
            particleDensity: 150,
            gravity: 0.15,
            drag: 0.98,
            trailFade: 0.15,
            multiBurstProb: 0.3,
            explosionForce: 8,
            seed: Math.floor(Math.random() * 100000),
            soundEnabled: true,
            volume: 0.5
        };

        // éŸ³é¢‘ç³»ç»Ÿ - ä½¿ç”¨Web Audio APIå®æ—¶ç”Ÿæˆæ›´é€¼çœŸçš„å£°éŸ³
        class AudioManager {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.masterGain = null;
                this.reverbNode = null;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();

                    // ä¸»éŸ³é‡æ§åˆ¶
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = params.volume;
                    this.masterGain.connect(this.ctx.destination);

                    // åˆ›å»ºæ··å“æ•ˆæœï¼ˆæ¨¡æ‹Ÿæˆ·å¤–ç©ºé—´å›å£°ï¼‰
                    this.createReverb();

                    this.initialized = true;
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }

            // åˆ›å»ºæ··å“æ•ˆæœ
            createReverb() {
                const convolver = this.ctx.createConvolver();
                const rate = this.ctx.sampleRate;
                const length = rate * 2; // 2ç§’æ··å“
                const impulse = this.ctx.createBuffer(2, length, rate);
                const left = impulse.getChannelData(0);
                const right = impulse.getChannelData(1);

                for (let i = 0; i < length; i++) {
                    const decay = Math.exp(-3 * i / length);
                    left[i] = (Math.random() * 2 - 1) * decay;
                    right[i] = (Math.random() * 2 - 1) * decay;
                }

                convolver.buffer = impulse;
                this.reverbNode = convolver;
            }

            // åˆ›å»ºå™ªå£°buffer
            createNoiseBuffer(duration = 2) {
                if (!this.ctx) return null;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    // ä½¿ç”¨æ›´å¹³æ»‘çš„å™ªå£°
                    data[i] = (Math.random() * 2 - 1) * 0.5;
                }
                return buffer;
            }

            // åˆ›å»ºç²‰çº¢å™ªå£°ï¼ˆæ›´æœ‰è´¨æ„Ÿï¼‰
            createPinkNoiseBuffer(duration = 2) {
                if (!this.ctx) return null;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                let b0, b1, b2, b3, b4, b5, b6;
                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;

                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }

                return buffer;
            }

            // æ›´é€¼çœŸçš„çˆ†ç‚¸å£°
            playExplosion(size = 1) {
                if (!this.initialized || !params.soundEnabled || !this.ctx) return;

                const t = this.ctx.currentTime;
                const volume = params.volume * size;

                // åˆ›å»ºä¸»å¢ç›ŠèŠ‚ç‚¹
                const mainGain = this.ctx.createGain();
                mainGain.connect(this.masterGain);
                mainGain.connect(this.reverbNode);
                this.reverbNode.connect(this.masterGain);

                // ============ ç¬¬1å±‚ï¼šä½é¢‘å†²å‡»ï¼ˆçˆ†ç‚¸çš„æ ¸å¿ƒè½°é¸£ï¼‰============
                const subBass = this.ctx.createOscillator();
                subBass.type = 'sine';
                subBass.frequency.setValueAtTime(150, t);
                subBass.frequency.exponentialRampToValueAtTime(40, t + 0.4);

                const subGain = this.ctx.createGain();
                // å¿«é€Ÿå†²å‡»åç¼“æ…¢è¡°å‡
                subGain.gain.setValueAtTime(0, t);
                subGain.gain.linearRampToValueAtTime(volume * 0.8, t + 0.01);
                subGain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

                subBass.connect(subGain);
                subGain.connect(mainGain);
                subBass.start(t);
                subBass.stop(t + 0.6);

                // ============ ç¬¬2å±‚ï¼šä¸­ä½é¢‘çˆ†ç‚¸å£°ï¼ˆä¸»ä½“çˆ†ç‚¸ï¼‰============
                const explosionNoise = this.ctx.createBufferSource();
                explosionNoise.buffer = this.createPinkNoiseBuffer(1.5);

                const midFilter = this.ctx.createBiquadFilter();
                midFilter.type = 'bandpass';
                midFilter.frequency.setValueAtTime(800, t);
                midFilter.frequency.exponentialRampToValueAtTime(200, t + 0.5);
                midFilter.Q.setValueAtTime(0.5, t);

                const midGain = this.ctx.createGain();
                midGain.gain.setValueAtTime(0, t);
                midGain.gain.linearRampToValueAtTime(volume * 0.6, t + 0.02);
                midGain.gain.exponentialRampToValueAtTime(0.001, t + 1.0);

                explosionNoise.connect(midFilter);
                midFilter.connect(midGain);
                midGain.connect(mainGain);
                explosionNoise.start(t);
                explosionNoise.stop(t + 1.0);

                // ============ ç¬¬3å±‚ï¼šé«˜é¢‘ç¢è£‚å£°ï¼ˆç«èŠ±é£æº…ï¼‰============
                const crackleNoise = this.ctx.createBufferSource();
                crackleNoise.buffer = this.createNoiseBuffer(0.8);

                const highFilter = this.ctx.createBiquadFilter();
                highFilter.type = 'highpass';
                highFilter.frequency.setValueAtTime(3000, t);
                highFilter.Q.setValueAtTime(2, t);

                const highGain = this.ctx.createGain();
                highGain.gain.setValueAtTime(0, t);
                highGain.gain.linearRampToValueAtTime(volume * 0.15, t + 0.01);
                highGain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

                crackleNoise.connect(highFilter);
                highFilter.connect(highGain);
                highGain.connect(mainGain);
                crackleNoise.start(t);
                crackleNoise.stop(t + 0.4);

                // ============ ç¬¬4å±‚ï¼šè¶…ä½é¢‘éœ‡åŠ¨ï¼ˆçˆ†ç‚¸çš„ä½™æ³¢ï¼‰============
                const rumble = this.ctx.createOscillator();
                rumble.type = 'sine';
                rumble.frequency.setValueAtTime(60, t);
                rumble.frequency.linearRampToValueAtTime(30, t + 0.8);

                const rumbleGain = this.ctx.createGain();
                rumbleGain.gain.setValueAtTime(0, t);
                rumbleGain.gain.linearRampToValueAtTime(volume * 0.3, t + 0.05);
                rumbleGain.gain.exponentialRampToValueAtTime(0.001, t + 1.2);

                rumble.connect(rumbleGain);
                rumbleGain.connect(mainGain);
                rumble.start(t);
                rumble.stop(t + 1.2);
            }

            // æ›´é€¼çœŸçš„çƒŸèŠ±ä¸Šå‡å£°ï¼ˆç®€æ´çš„"å—–"å£°ï¼‰
            playLaunch() {
                if (!this.initialized || !params.soundEnabled || !this.ctx) return;

                const t = this.ctx.currentTime;
                const volume = params.volume * 0.15;

                // ä¸»éŸ³é‡åŒ…ç»œ
                const mainGain = this.ctx.createGain();
                mainGain.connect(this.masterGain);
                mainGain.connect(this.reverbNode);
                this.reverbNode.connect(this.masterGain);

                // ============ ä¸»å•¸å«å£°ï¼ˆç®€å•çš„é¢‘ç‡ä¸Šå‡ï¼‰============
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                // é¢‘ç‡ä»ä½åˆ°é«˜ï¼Œæ¨¡æ‹Ÿä¸Šå‡
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.exponentialRampToValueAtTime(1500, t + 0.7);

                const oscGain = this.ctx.createGain();
                // æ·¡å…¥æ·¡å‡º
                oscGain.gain.setValueAtTime(0, t);
                oscGain.gain.linearRampToValueAtTime(volume * 0.5, t + 0.1);
                oscGain.gain.linearRampToValueAtTime(0, t + 0.7);

                osc.connect(oscGain);
                oscGain.connect(mainGain);
                osc.start(t);
                osc.stop(t + 0.7);

                // ============ ç©ºæ°”å˜¶å˜¶å£° ============
                const noise = this.ctx.createBufferSource();
                noise.buffer = this.createNoiseBuffer(0.7);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(2000, t);
                filter.frequency.exponentialRampToValueAtTime(5000, t + 0.6);
                filter.Q.setValueAtTime(1, t);

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(volume * 0.08, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(mainGain);
                noise.start(t);
                noise.stop(t + 0.6);
            }

            // æ›´é€¼çœŸçš„å°å‹çˆ†ç‚¸ï¼ˆå¤šé‡çˆ†ç‚¸ï¼‰
            playMiniExplosion() {
                if (!this.initialized || !params.soundEnabled || !this.ctx) return;

                const t = this.ctx.currentTime;
                const volume = params.volume * 0.35;

                const mainGain = this.ctx.createGain();
                mainGain.connect(this.masterGain);
                mainGain.connect(this.reverbNode);
                this.reverbNode.connect(this.masterGain);

                // ä½é¢‘
                const subOsc = this.ctx.createOscillator();
                subOsc.type = 'sine';
                subOsc.frequency.setValueAtTime(200, t);
                subOsc.frequency.exponentialRampToValueAtTime(80, t + 0.2);

                const subGain = this.ctx.createGain();
                subGain.gain.setValueAtTime(volume * 0.5, t);
                subGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);

                subOsc.connect(subGain);
                subGain.connect(mainGain);
                subOsc.start(t);
                subOsc.stop(t + 0.25);

                // çˆ†ç‚¸å™ªå£°
                const noise = this.ctx.createBufferSource();
                noise.buffer = this.createPinkNoiseBuffer(0.5);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1200, t);
                filter.frequency.exponentialRampToValueAtTime(300, t + 0.25);
                filter.Q.setValueAtTime(1, t);

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(volume * 0.4, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(mainGain);
                noise.start(t);
                noise.stop(t + 0.3);
            }

            // æ›´æ–°ä¸»éŸ³é‡
            setVolume(value) {
                if (this.masterGain) {
                    this.masterGain.gain.setValueAtTime(
                        value,
                        this.ctx.currentTime
                    );
                }
            }
        }

        const audioManager = new AudioManager();

        // è‰²å½©æ–¹æ¡ˆå®šä¹‰
        const colorSchemes = {
            rainbow: {
                name: 'ç»šçƒ‚å½©è™¹',
                getGradient: (t) => {
                    // t ä» 0 åˆ° 1ï¼Œä»£è¡¨èƒ½é‡ç­‰çº§
                    const hues = [0, 30, 60, 120, 180, 240, 280, 320];
                    const hue = hues[Math.floor(t * (hues.length - 1))];
                    return `hsl(${hue}, 100%, ${50 + t * 30}%)`;
                }
            },
            fire: {
                name: 'ç«ç„°çƒˆç„°',
                getGradient: (t) => {
                    // ä»ç™½åˆ°é»„åˆ°æ©™åˆ°çº¢
                    const r = 255;
                    const g = Math.floor(200 + t * 55);
                    const b = Math.floor(t * 100);
                    const a = 0.3 + t * 0.7;
                    return `rgba(${r}, ${g}, ${b}, ${a})`;
                }
            },
            ice: {
                name: 'å†°é›ªå¯’éœœ',
                getGradient: (t) => {
                    const r = Math.floor(t * 150);
                    const g = Math.floor(150 + t * 105);
                    const b = 255;
                    const a = 0.3 + t * 0.7;
                    return `rgba(${r}, ${g}, ${b}, ${a})`;
                }
            },
            gold: {
                name: 'é»„é‡‘è£è€€',
                getGradient: (t) => {
                    const r = 255;
                    const g = Math.floor(180 + t * 75);
                    const b = Math.floor(t * 100);
                    const a = 0.4 + t * 0.6;
                    return `rgba(${r}, ${g}, ${b}, ${a})`;
                }
            },
            neon: {
                name: 'éœ“è™¹èµ›åš',
                getGradient: (t) => {
                    const hues = [300, 180, 60];  // ç´«é’é»„
                    const hue = hues[Math.floor(t * 2.99)];
                    return `hsl(${hue}, 100%, ${50 + t * 30}%)`;
                }
            },
            sunset: {
                name: 'æ—¥è½æ™šéœ',
                getGradient: (t) => {
                    const r = 255;
                    const g = Math.floor(100 + t * 100);
                    const b = Math.floor(50 + t * 150);
                    const a = 0.3 + t * 0.7;
                    return `rgba(${r}, ${g}, ${b}, ${a})`;
                }
            }
        };

        let fireworks = [];
        let particles = [];
        let canvas;

        // è®¾ç½®éšæœºç§å­
        function setSeed(s) {
            params.seed = s;
            randomSeed(s);
            noiseSeed(s);
        }

        // ç²’å­ç±» - æ ¸å¿ƒç®—æ³•å•å…ƒ
        class Particle {
            constructor(x, y, color, force) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D().mult(force * random(0.5, 1.5));
                this.acc = createVector(0, 0);

                // è‰ºæœ¯æ¨¡å¼ä¸‹å¯èƒ½å‘ä¸Š
                if (params.mode === 'artistic' && random() < 0.3) {
                    this.vel.y *= -0.5;  // éƒ¨åˆ†ç²’å­å‘ä¸Š
                }

                this.color = color;
                this.life = 1.0;
                this.decay = random(0.005, 0.02);

                // é€Ÿåº¦å†å²ï¼ˆç”¨äºæ¸²æŸ“æµçº¿è½¨è¿¹ï¼‰
                this.history = [];
                this.maxHistory = 5;

                // å¤šé‡çˆ†ç‚¸æ ‡è®°
                this.canMultiBurst = random() < params.multiBurstProb;
                this.hasMultiBurst = false;
            }

            applyForce(force) {
                this.acc.add(force);
            }

            // åŸºäºé€Ÿåº¦è®¡ç®—èƒ½é‡ç­‰çº§ï¼ˆ0-1ï¼‰
            getEnergyLevel() {
                const speed = this.vel.mag();
                const maxSpeed = params.explosionForce * 2;
                return constrain(speed / maxSpeed, 0, 1);
            }

            // åŠ¨æ€é¢œè‰²è®¡ç®— - åŸºäºé€Ÿåº¦å’Œç”Ÿå‘½
            getDynamicColor() {
                const energy = this.getEnergyLevel();
                const lifeFactor = this.life;

                const scheme = colorSchemes[params.colorScheme];
                let baseColor = scheme.getGradient(energy);

                // å åŠ ç”Ÿå‘½æœŸé€æ˜åº¦
                if (baseColor.startsWith('hsl')) {
                    baseColor = baseColor.replace(')', `, ${this.life * 0.8})`).replace('hsl', 'hsla');
                } else {
                    baseColor = baseColor.replace(/,[^,]+\)$/, `,${this.life * 0.8})`);
                }

                return baseColor;
            }

            update() {
                // åº”ç”¨é‡åŠ›
                let gravity = createVector(0, params.gravity);

                // è‰ºæœ¯æ¨¡å¼ä¸‹çš„ç‰©ç†å˜å¥
                if (params.mode === 'artistic') {
                    // éšæœºæ‰°åŠ¨ï¼ˆæ¨¡æ‹Ÿç©ºæ°”æ¹æµï¼‰
                    if (random() < 0.1) {
                        gravity.x += random(-0.02, 0.02);
                    }
                    // ä½é€Ÿç²’å­å¯èƒ½å‘ä¸Šæ¼‚æµ®
                    if (this.vel.mag() < 1 && random() < 0.02) {
                        gravity.y = -0.05;
                    }
                }

                this.applyForce(gravity);

                this.vel.add(this.acc);
                this.vel.mult(params.drag);
                this.pos.add(this.vel);
                this.acc.mult(0);

                // è®°å½•è½¨è¿¹å†å²
                this.history.push(this.pos.copy());
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }

                this.life -= this.decay;

                // å¤šé‡çˆ†ç‚¸æ£€æµ‹
                if (this.canMultiBurst && !this.hasMultiBurst &&
                    this.life < 0.5 && this.vel.mag() < 2) {
                    this.hasMultiBurst = true;
                    this.multiBurst();
                }
            }

            multiBurst() {
                // æ’­æ”¾å°å‹çˆ†ç‚¸éŸ³æ•ˆ
                audioManager.playMiniExplosion();

                // äºŒæ¬¡çˆ†ç‚¸
                const burstCount = Math.floor(random(10, 20));
                const burstForce = params.explosionForce * 0.4;

                for (let i = 0; i < burstCount; i++) {
                    const p = new Particle(this.pos.x, this.pos.y, this.color, burstForce);
                    p.life = 0.5;  // äºŒæ¬¡ç²’å­å¯¿å‘½æ›´çŸ­
                    p.canMultiBurst = false;  // ä¸å†ç»§ç»­çˆ†ç‚¸
                    particles.push(p);
                }
            }

            display() {
                const dynamicColor = this.getDynamicColor();

                // ç»˜åˆ¶æµçº¿è½¨è¿¹ï¼ˆåŸºäºå†å²ä½ç½®ï¼‰
                if (this.history.length > 1) {
                    noFill();
                    strokeWeight(2);
                    stroke(dynamicColor);

                    beginShape();
                    for (let i = 0; i < this.history.length; i++) {
                        const alpha = (i / this.history.length) * this.life;
                        const pos = this.history[i];
                        vertex(pos.x, pos.y);
                    }
                    vertex(this.pos.x, this.pos.y);
                    endShape();
                }

                // ç»˜åˆ¶ç²’å­ä¸»ä½“
                noStroke();
                fill(dynamicColor);

                const size = this.life * (params.mode === 'artistic' ? 4 : 3);
                circle(this.pos.x, this.pos.y, size);

                // é«˜èƒ½ç²’å­å‘å…‰æ•ˆæœ
                if (this.getEnergyLevel() > 0.5) {
                    fill(dynamicColor);
                    circle(this.pos.x, this.pos.y, size * 2);
                }
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // çƒŸèŠ±ç±»
        class Firework {
            constructor(x, targetY) {
                // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
                audioManager.init();
                audioManager.playLaunch();

                this.pos = createVector(x, height);
                this.targetY = targetY;
                this.vel = createVector(0, random(-12, -8));
                this.acc = createVector(0, 0);
                this.exploded = false;
                this.color = color(random(255), random(255), random(255));

                // ä¸Šå‡è½¨è¿¹
                this.trail = [];
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                // ä¸Šå‡é˜¶æ®µ
                if (!this.exploded) {
                    this.applyForce(createVector(0, 0.2));  // é‡åŠ›
                    this.vel.add(this.acc);
                    this.pos.add(this.vel);
                    this.acc.mult(0);

                    // è®°å½•ä¸Šå‡è½¨è¿¹
                    this.trail.push(this.pos.copy());
                    if (this.trail.length > 10) {
                        this.trail.shift();
                    }

                    // åˆ°è¾¾ç›®æ ‡é«˜åº¦æˆ–é€Ÿåº¦å‡æ…¢æ—¶çˆ†ç‚¸
                    if (this.pos.y <= this.targetY || this.vel.y >= 0) {
                        this.explode();
                    }
                }
            }

            explode() {
                this.exploded = true;

                // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆï¼ˆæ ¹æ®ç²’å­å¯†åº¦è°ƒæ•´éŸ³é‡ï¼‰
                const size = params.particleDensity / 150;
                audioManager.playExplosion(size);

                // åˆ›å»ºçˆ†ç‚¸ç²’å­
                const count = params.particleDensity;
                for (let i = 0; i < count; i++) {
                    const p = new Particle(
                        this.pos.x,
                        this.pos.y,
                        this.color,
                        params.explosionForce
                    );
                    particles.push(p);
                }
            }

            display() {
                if (!this.exploded) {
                    // ç»˜åˆ¶ä¸Šå‡è½¨è¿¹
                    if (this.trail.length > 1) {
                        stroke(255, 200);
                        strokeWeight(2);
                        noFill();
                        beginShape();
                        for (let pos of this.trail) {
                            vertex(pos.x, pos.y);
                        }
                        vertex(this.pos.x, this.pos.y);
                        endShape();
                    }

                    // ç»˜åˆ¶ç«ç®­å¤´éƒ¨
                    noStroke();
                    fill(255, 255, 200);
                    circle(this.pos.x, this.pos.y, 4);
                }
            }

            isDead() {
                return this.exploded;
            }
        }

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('canvas-container');

            // åˆå§‹åŒ–ç§å­
            setSeed(params.seed);

            // è®¾ç½®UI
            setupUI();

            background(10, 10, 15);
        }

        function setupUI() {
            // æ¨¡å¼é€‰æ‹©
            const modeSelect = document.getElementById('mode-select');
            const modeInfo = document.getElementById('mode-info');
            const currentMode = document.getElementById('current-mode');

            modeSelect.addEventListener('change', (e) => {
                params.mode = e.target.value;
                if (params.mode === 'physics') {
                    modeInfo.innerHTML = '<strong>ç‰©ç†ç°å®ä¸»ä¹‰ï¼š</strong>éµå¾ªç»å…¸åŠ›å­¦å®šå¾‹ï¼Œç²’å­å—é‡åŠ›å½±å“è‡ªç„¶ä¸‹è½ï¼Œå½¢æˆçœŸå®çš„æŠ›ç‰©çº¿è½¨è¿¹ã€‚é€‚åˆè¿½æ±‚ç‰©ç†å¯ä¿¡åº¦çš„è§†è§‰æ•ˆæœã€‚';
                    currentMode.textContent = 'ç‰©ç†ç°å®ä¸»ä¹‰';
                    params.gravity = 0.15;
                    params.drag = 0.98;
                } else {
                    modeInfo.innerHTML = '<strong>è¡¨ç°è‰ºæœ¯è‡ªç”±ï¼š</strong>æ‰“ç ´ç‰©ç†å®šå¾‹ï¼Œç²’å­å¯ä»¥åæŠ—é‡åŠ›å‘ä¸Šæ¼‚æµ®ï¼Œåœ¨ç©ºé—´ä¸­åˆ›é€ å‡ºæ¢¦å¹»çš„ã€è¶…ç°å®çš„è§†è§‰æ•ˆæœã€‚ç©ºæ°”é˜»åŠ›å¯èƒ½åè½¬ï¼Œæ—¶é—´æ„ŸçŸ¥æ‰­æ›²ã€‚';
                    currentMode.textContent = 'è¡¨ç°è‰ºæœ¯è‡ªç”±';
                    params.gravity = -0.05;
                    params.drag = 1.0;
                }
                document.getElementById('gravity-slider').value = params.gravity;
                document.getElementById('gravity-value').textContent = params.gravity;
                document.getElementById('drag-slider').value = params.drag;
                document.getElementById('drag-value').textContent = params.drag;
            });

            // è‰²å½©é€‰æ‹©
            document.getElementById('color-select').addEventListener('change', (e) => {
                params.colorScheme = e.target.value;
            });

            // æ»‘å—æ§åˆ¶
            const sliders = [
                { id: 'count-slider', param: 'fireworkCount', display: 'count-value' },
                { id: 'density-slider', param: 'particleDensity', display: 'density-value' },
                { id: 'gravity-slider', param: 'gravity', display: 'gravity-value' },
                { id: 'drag-slider', param: 'drag', display: 'drag-value' },
                { id: 'trail-slider', param: 'trailFade', display: 'trail-value' },
                { id: 'multi-slider', param: 'multiBurstProb', display: 'multi-value', transform: v => v / 100, displayTransform: v => v + '%' },
                { id: 'force-slider', param: 'explosionForce', display: 'force-value' }
            ];

            sliders.forEach(({ id, param, display, transform, displayTransform }) => {
                const slider = document.getElementById(id);
                const displayEl = document.getElementById(display);

                slider.addEventListener('input', (e) => {
                    let value = parseFloat(e.target.value);
                    params[param] = transform ? transform(value) : value;
                    displayEl.textContent = displayTransform ? displayTransform(value) : value;
                });
            });

            // å‘å°„æŒ‰é’®
            document.getElementById('launch-btn').addEventListener('click', launchFireworks);

            // æ¸…é™¤æŒ‰é’®
            document.getElementById('clear-btn').addEventListener('click', () => {
                fireworks = [];
                particles = [];
                background(10, 10, 15);
            });

            // æ›´æ–°ç§å­æ˜¾ç¤º
            document.getElementById('seed-display').textContent = params.seed;

            // éŸ³æ•ˆæ§åˆ¶
            const muteBtn = document.getElementById('mute-btn');
            const volumeSlider = document.getElementById('volume-slider');

            muteBtn.addEventListener('click', () => {
                audioManager.init();  // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–
                params.soundEnabled = !params.soundEnabled;
                muteBtn.textContent = params.soundEnabled ? 'ğŸ”Š å¼€å¯éŸ³æ•ˆ' : 'ğŸ”‡ é™éŸ³';
            });

            volumeSlider.addEventListener('input', (e) => {
                const value = e.target.value / 100;
                params.volume = value;
                audioManager.setVolume(value);
            });

            // åˆ‡æ¢æ§åˆ¶é¢æ¿
            const toggleBtn = document.getElementById('toggle-controls');
            const controls = document.getElementById('controls');
            let controlsVisible = true;

            toggleBtn.addEventListener('click', () => {
                controlsVisible = !controlsVisible;
                controls.classList.toggle('hidden', !controlsVisible);
                toggleBtn.classList.toggle('shifted', controlsVisible);
                toggleBtn.textContent = controlsVisible ? 'âš™ï¸' : 'ğŸ†';
            });
        }

        function launchFireworks() {
            // æ›´æ–°ç§å­
            params.seed = Math.floor(random(10000, 99999));
            setSeed(params.seed);
            document.getElementById('seed-display').textContent = params.seed;

            // å‘å°„æŒ‡å®šæ•°é‡çš„çƒŸèŠ±
            for (let i = 0; i < params.fireworkCount; i++) {
                setTimeout(() => {
                    const x = random(width * 0.2, width * 0.8);
                    const targetY = random(height * 0.2, height * 0.5);
                    fireworks.push(new Firework(x, targetY));
                }, i * 300);
            }
        }

        function draw() {
            // è½¨è¿¹è¡°å‡æ•ˆæœï¼ˆé€šè¿‡åŠé€æ˜èƒŒæ™¯è¦†ç›–ï¼‰
            background(10, 10, 15, params.trailFade * 255);

            // æ›´æ–°å’Œç»˜åˆ¶æ‰€æœ‰çƒŸèŠ±
            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].update();
                fireworks[i].display();

                if (fireworks[i].isDead()) {
                    fireworks.splice(i, 1);
                }
            }

            // æ›´æ–°å’Œç»˜åˆ¶æ‰€æœ‰ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].display();

                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            document.getElementById('particle-count').textContent = particles.length;
            document.getElementById('firework-count').textContent = fireworks.length;

            // è‡ªåŠ¨å‘å°„ï¼ˆå¦‚æœç²’å­å¤ªå°‘ï¼‰
            if (particles.length < 50 && fireworks.length === 0 && random() < 0.01) {
                const x = random(width * 0.2, width * 0.8);
                const targetY = random(height * 0.2, height * 0.5);
                fireworks.push(new Firework(x, targetY));
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            background(10, 10, 15);
        }

        // ç‚¹å‡»ç”»å¸ƒå‘å°„å•ä¸ªçƒŸèŠ±
        function mousePressed() {
            const controls = document.getElementById('controls');
            const isControlsHidden = controls.classList.contains('hidden');

            // å¦‚æœé¢æ¿éšè—ï¼Œä»»æ„ä½ç½®å¯ç‚¹å‡»ï¼›å¦‚æœé¢æ¿æ˜¾ç¤ºï¼Œé¿å¼€é¢æ¿åŒºåŸŸ
            if (isControlsHidden || mouseX > 360) {
                fireworks.push(new Firework(mouseX, mouseY));
            }
        }
    </script>
</body>
</html>